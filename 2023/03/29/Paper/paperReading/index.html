<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Aiming">





<title>paperReading | (●&#39;◡&#39;●)Iminslife</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/null"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Iminslife</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Iminslife</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">paperReading</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Aiming</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 29, 2023&nbsp;&nbsp;9:25:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Paper/">Paper</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="1、Foreformer-an-enhanced-transformer-based-framework-for-multivariate-time-series-forecasting"><a href="#1、Foreformer-an-enhanced-transformer-based-framework-for-multivariate-time-series-forecasting" class="headerlink" title="1、Foreformer: an enhanced transformer-based framework for multivariate time series forecasting"></a>1、Foreformer: an enhanced transformer-based framework for multivariate time series forecasting</h1><h3 id="一、文献来源"><a href="#一、文献来源" class="headerlink" title="一、文献来源"></a>一、文献来源</h3><p>来自于浙江大学发表的这篇文章是主要基于transformer改进的多元时间序列预测网络。作者认为，transformer不能直接应用于多元时间序列。比如：在不同的时间尺度上提取的时间模式不足，特别是在自注意力机制中提取很多无关的信息，这一点，之前也有很多文章做过相关的工作。此外，没有针对静态协变量做针对性的处理。所以作者提出了这个改进的模型。</p>
<p>论文链接：<a target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s10489-022-04100-3">https://link.springer.com/article/10.1007/s10489-022-04100-3</a></p>
<h3 id="二、动机与贡献"><a href="#二、动机与贡献" class="headerlink" title="二、动机与贡献"></a>二、动机与贡献</h3><h4 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h4><ul>
<li>在经典的Transformer模型中没有提取不同时间尺度上的特征</li>
</ul>
<p>因为，时间序列包括一些长期的趋势和短期的趋势，这个长期的趋势和短期的趋势分别反映总体的时间序列趋势和局部时间段的细微变化。从这一点上来说，在时间序列中分析提取中长期和短期时间模式本质上是不同时间尺度的特征提取过程。</p>
<p>但是在transformer模型中并没有这样的操作。一些其他的方法，比如CNN，TCN的方法可以进行多尺度的特征提取，但是这些方法需要进行以0填充，就导致在计算的过程中引入额外的元素了（指的是填充的部分）</p>
<ul>
<li>自注意力机制中对所有元素计算，存在不相关的计算降低预测性能</li>
</ul>
<p>因为，在自注意力机制中是通过对序列的所有元素复制，会对所有的元素不加以区分的计算。具体来说，每一个位置的 $q$ 都要和其他所有位置的 $k$ 进行计算，这导致，序列中不相关的位置导致预测性能降低。</p>
<ul>
<li>简单的处理静态协变量可能达不到理想的预测效果</li>
</ul>
<p>在时间序列中，不仅包括了动态的时间序列变量，也包含了静态的协变量。那么什么是静态的协变量呢？ 举个例子来说吧：我有几个风力发电站，我想预测每个风力发电站的发电量，可能风电站的位置对预测也很重要，所以它的位置坐标可以当成协变量，之所以称为静态的，是因为对每个发电站来说，位置永远是不变的。在工业的一些数据集中，也存在着非常多的这样的静态协变量。</p>
<h4 id="2-2-贡献"><a href="#2-2-贡献" class="headerlink" title="2.2 贡献"></a>2.2 贡献</h4><ul>
<li>针对不同分辨率下时序预测，提出了一种多时间分辨率的模块。该模块通过迭代的方式在不同的时间分辨率下进行交互学习生成时间序列的有效表示</li>
<li>针对自注意力机制，提出了一种新的显式稀疏多头注意力机制取代原来的自注意力机制，目的是为了使得模型更加专注更加重要的成分</li>
<li>针对静态协变量，提出一种静态协变量处理模块。这个模块引入门机制，过滤掉不重要的信息</li>
</ul>
<h3 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h3><h4 id="3-1-总体框架结构"><a href="#3-1-总体框架结构" class="headerlink" title="3.1 总体框架结构"></a>3.1 总体框架结构</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291017393.png" alt="image-20230329101715267" style="zoom:67%;" /></p>
<p>总体上来说：原始的数据输入被分为两个部分，一个是时间序列的输入，一个是静态协变量的输入。针对时间序列的输入，首先经过一个线性映射，然后将结果传递给多时间分辨率模块，得到不同的时间尺度下的特征信息，然后下一步结合位置编码输入到下一层的基于transformer的编码器结构中处理输出。针对静态协变量，输入到静态协变量处理模块，进行非线性处理输出。最后，将这两个部分的输出进行拼接，经过全连接层得到最终的预测结果。</p>
<p>下面，我们分别来讲，上面模型中的三个主要部分：一个是多时间分辨率模块，一个是编码器和解码器框架，最后是这个静态协变量处理模块。其他的线性投影、通过线性函数和三角函数处理的位置编码这里就不做讨论了</p>
<h4 id="3-2-多时间分辨率模块"><a href="#3-2-多时间分辨率模块" class="headerlink" title="3.2 多时间分辨率模块"></a>3.2 多时间分辨率模块</h4><p>在这个多时间分辨率模块中，它是基于二叉树结构的。对时间序列以一种迭代的方式进行下采样，然后，对每个子序列进行特征提取和交互学习操作，最后合并对齐生成新的输入序列。</p>
<p>这个网络结构其实和我之前看的一篇文章非常相似，说的更准确来说，这个模块的提出其实就是那篇文章模型的简化版，直接拿来用的。下面，我们来看这篇文章的说的这个模块结构：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291036061.png" alt="image-20230329103628968" style="zoom:67%;" /></p>
<p>总的结构是左边这种以二叉树结构组成的结构，其中子模块就是右边这种处理方式。将时间序列分解成两个子序列，这是通过奇偶分解的方式分解，即奇数位置的元素都在左边，偶数位置的元素都在右边。然后，针对这两个子序列，进行卷积操作，将其投影到隐藏状态，并通过激活函数输出，和另外一个序列进行交互学习操作。如何理解这个交互学习操作，其实非常简单，就是两个序列做<code>Hadamard product</code> 或者 <code>element-wise production</code>。但是，作者解释这个东西为：这两个序列进行缩放变换，缩放变换的因子是使用不同的卷积核来相互学习的。也就是说，它们经过两个不一样的卷积网络。</p>
<p>此外：上面的激活函数，增加了函数的非线性，有利于模型的训练。这个模块的优势是，将时间序列不断分解，并且在不同的分辨率下（不同时间尺度下）进行提取特征。</p>
<p>最后，由于之前分解都是按照奇偶分解操作的，最后输出的时候，要把序列进行一个拼接，再还原成原始序列次序的这么一个操作，保证序列在输入和输出的相对位置不变，防止信息丢失。具体流程，右下角这个图。实际的操作是以一种递归的方式完成的，在不断拼接的过程中，同时进行重组。</p>
<h4 id="3-3-显示稀疏多头注意"><a href="#3-3-显示稀疏多头注意" class="headerlink" title="3.3 显示稀疏多头注意"></a>3.3 显示稀疏多头注意</h4><p>一种具有显式注意分值选择策略的稀疏多头注意机制，使得模型更专注于贡献更大的信息，忽略不相关的信息。我们具体通过一个单头的注意力值计算过程来说，因为多头和这个过程一样。具体来说：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291228749.png" alt="image-20230329122852678" style="zoom:67%;" /></p>
<ul>
<li><p>首先，计算得分矩阵 $S=\frac{QK^{\top}}{\sqrt{d_k}}$ ，这一步和原来的操作过程一样。这个等分矩阵有个特征，中间的一个数据越高，说明这两个位置的相关性越高。</p>
</li>
<li><p>随后，对得分矩阵S进行注意过滤操作。这是以百分比参数利用比率 <code>employ rate</code> 来过滤除贡献最大的元素。具体操作公式如下：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291200762.png" alt="image-20230329120000687"></p>
<p>也就是说，当得分矩阵中的某个值大于实验设定的阈值时，保留这个数，如果小于这个设定的阈值时，设置为 $-\infty$  通过这样一种过滤操作显示的选择较高的注意力分数的元素，比dropout随机忽略值相比要更加准确一些。也容易根据实验进行调整。因为是一个超参数。</p>
</li>
<li><p>接下来：计算归一化得分：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291207215.png" alt="image-20230329120705171"></p>
<p>这里$sign$函数表示符号函数，将经过选择处理后的得分矩阵转化为0-1的二进制矩阵<code>Mask</code>。也即是说明，在这个矩阵上，之前有数字的位置转变成1，$- \infty$的位置全部变成0。</p>
<p>在我看来，这一步和上一步表述上有出入，或者说是作者没有讲清楚。下面这个公式是上面那个公式的具体体现，仅仅是多了一个<code>softmax</code>操作而已。其中具体过程用下面这个公式具体表示而已。如果，不这样解释，那么这两个公式之间就会显得重复，而且公式9也没有必要重复这么操作。</p>
</li>
<li><p>最后，得到这个<code>weight</code>权重之后，乘以<code>V</code>得到注意力值：$Attn = Weight · V$ </p>
</li>
</ul>
<h4 id="3-4-静态变量处理模块"><a href="#3-4-静态变量处理模块" class="headerlink" title="3.4 静态变量处理模块"></a>3.4 静态变量处理模块</h4><p>这个模块是可选模块，假如，一个数据集中有这个静态协变量，就会用到这个模块，如果没有，就是上面模块的处理。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291236319.png" alt="image-20230329123634246" style="zoom:67%;" /></p>
<p>其中：操作工程用公式表示为：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291238841.png" alt="image-20230329123839804"></p>
<p>这里$\sigma$表示<code>sigmoid</code>激活函数，$W_1, b_1$表示可学习的参数。$Gate(·)$是基于门控线性单元<code>GLU</code>的计算操作，它可以增强对静态协变量输入进行非线性处理的灵活性。当这个变量和预测目标值不相关时，对应<code>sigmoid</code>输出的值就会趋近于0。</p>
<p><code>GLU</code>是基于<code>LSTM</code>的一个优化算法。是一种简化的门控机制，缓解LSTM的一个梯度消失的问题。具体参考文献：<a target="_blank" rel="noopener" href="http://proceedings.mlr.press/v70/dauphin17a.html?ref=https://githubhelp.com">Language modeling with gated convolutional networks</a></p>
<p>最后得到的hidden state输出后和编码器解码器框架的输出拼接在一起，传入全连接层。得到最终的预测</p>
<h3 id="四、实验"><a href="#四、实验" class="headerlink" title="四、实验"></a>四、实验</h3><h4 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1 数据集"></a>4.1 数据集</h4><ul>
<li>Exchange rate</li>
<li>Electricity</li>
<li>Mooney Viscosity: 这个数据集记录了杭州一个橡胶精炼厂的一些数据。这个数据包含了时间序列变量和静态协变量，这项数据是决定橡胶质量的一个重要指标。</li>
</ul>
<h4 id="4-2-评价标准"><a href="#4-2-评价标准" class="headerlink" title="4.2 评价标准"></a>4.2 评价标准</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291302973.png" alt="image-20230329130229919" style="zoom: 67%;" /></p>
<h4 id="4-3-主要结果"><a href="#4-3-主要结果" class="headerlink" title="4.3 主要结果"></a>4.3 主要结果</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291305886.png" alt="image-20230329130527798" style="zoom: 80%;" /></p>
<h4 id="4-4-消融实验"><a href="#4-4-消融实验" class="headerlink" title="4.4 消融实验"></a>4.4 消融实验</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291312118.png" alt="image-20230329131252033" style="zoom:67%;" /></p>
<ul>
<li><code>ES-MHA</code>：指的是去掉了显示多头注意机制，用传统的自注意力机制代替的变体模型</li>
<li><code>MTR</code>: 表示去掉了多分辨率模块，用正常的卷积模块代替的变体模型</li>
<li><code>Inter</code>：表示在多分辨率模块的子模块中，去掉了两个子序列之间的交互学习操作，直接输出两个子序列的变体模型</li>
<li><code>SCP</code>：表示去掉了静态协变量处理模块。在这里，由于前面两个数据集不包括静态协变量，所以，这部分实验结果是空的。</li>
</ul>
<h4 id="4-5-效率分析"><a href="#4-5-效率分析" class="headerlink" title="4.5 效率分析"></a>4.5 效率分析</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291319443.png" alt="image-20230329131920380" style="zoom:67%;" /></p>
<p>可以看的出来，这个模型还是有不足的，主要体现在模型的计算效率比原始的transformer模型处理速度上变得更慢了，同时它的计算量也比原版的要高很多。这是因为，它在开始的多分辨率模块下，以及在静态变量处理模块中进行了大量的卷积和全连接操作，造成效率较低。</p>
<h4 id="4-6-超参数分析"><a href="#4-6-超参数分析" class="headerlink" title="4.6 超参数分析"></a>4.6 超参数分析</h4><p><img src="https://gcore.jsdelivr.net/gh/Iminscode/typora-img-store@main/imgs/202303291322895.png" alt="image-20230329132226817" style="zoom:67%;" /></p>
<p>在超参数分析的过程中，作者分析了，在得分矩阵百分比利用比率选取，在线性投影过程中维度的影响，在多分辨率模块下的卷积核大小的影响，在多分辨率模块下模块堆叠的层数的影响。在编码器和解码器框架中各自堆叠的层数分析。</p>
<h1 id="2-Markovian-RNN-An-Adaptive-Time-Series-Prediction-Network-With-HMM-Based-Switching-for-Nonstationary-Environments"><a href="#2-Markovian-RNN-An-Adaptive-Time-Series-Prediction-Network-With-HMM-Based-Switching-for-Nonstationary-Environments" class="headerlink" title="2 Markovian RNN: An Adaptive Time Series Prediction Network With HMM-Based Switching for Nonstationary Environments"></a>2 Markovian RNN: An Adaptive Time Series Prediction Network With HMM-Based Switching for Nonstationary Environments</h1><p>标题：马尔可夫RNN:非平稳环境下基于hmm切换的自适应时序预测网络</p>
<p>在大多数业务场景下，如金融，零售，能源和经济等，它们都是动态随时间变化的，时间序列数据表现出一种非平稳特性</p>
<p>基于这个问题，作者提出一种新的循环神经网络，它是以马尔可夫式自适应地在内部机制之间来切换，来模型给定数据的非平稳性质。这个新模型称之为马尔可夫RNN</p>
<p>模型采用隐马尔可夫(HMM)进行状态转换，其中每一个状态独立控制循环细胞的隐藏状态转换。</p>
<p>一组<font color='orange'>专家算法</font>是指将多个不同的算法或模型组合在一起，利用它们的优势来处理复杂的回归问题，提高预测的准确性。这些算法可以是同一种类型的（例如多个决策树）或不同类型的模型（例如一个决策树，一个支持向量机和一个神经网络），这里的每一个模型，在文章中表示为一个专家。通常需要使用某种投票或加权方案来集成它们的结果。这其中的加权方案的控制被称之为<font color='orange'>门控模型</font>：用于控制每个专家的权重。对于一个复杂的预测任务来说，选择门控模型和选择专家模型同样重要。</p>
<p>大多数研究中，特别是商业和金融领域，比较倾向于使用基于马尔可夫转换的方法来预测。那么什么是<font color='orange'>基于马尔可夫转换方法</font>呢：它是假设当前时刻的状态仅依赖于前面的有限个状态，而不依赖于更早的状态或未来状态。基于这个性质，就可以通过时间序列所处的某个特定状态，以及在状态与状态之间转移的概率来描述时间序列的演化过程和预测。</p>
<p>但是这类方法，在建模方面并不灵活，因为，它假设了序列具有某种<font color='orange'>变化均值和方差</font>，这些值是假设的，但是在实际现实数据中，这些假设不一定成立。所以，模型也就无法很好的适应真实数据的变化。</p>
<p>这类方法虽然应用场景是在非平稳数据预测任务下的，但是它<font color='orange'>本质还是采用的线性模型</font>，很少有考虑非线性模型的。并且需要多次训练，反复估计参数，每次训练的结果可能不一样，最后需要取平均或者是取最优结果。</p>
<p>另外一点。这类方法，是采用的<font color='orange'>分解</font>的方法，也就是把数据分解为多个独立的部分，并对这些部分分别进行建模，初衷是为了去降低数据的一个复杂性，每一个子序列用单独的专家模型来进行预测来提高预测能力，但也可能导致信息丢失，因为多个独立部分可能存在交叉或者交互作用。因此，这类方法不能联合起来进行整体地优化，它如果要优化的话，就需要对每一个专家模型进行单独的优化。</p>
<p>基于这个问题：作者提出了一种联合优化的框架。这个框架可以有效的利用RNN的非线性建模能力，同时，利用HMM的自适应马尔可夫切换的好处。<font color='orange'>RNN细胞单元</font>内的<font color='orange'>隐藏状态转移权重</font>被看作是<font color='orange'>专家</font>，用于对数据进行建模。同时，<font color='orange'>基于HMM的马尔可夫切换</font>被用于在不同专家之间进行<font color='orange'>门控操作</font>，以便在不同区域之间切换，以更好地适应非平稳性的数据。</p>
<p>如何理解：它这个切换是用在不同专家之间来进行门控操作呢：当HMM模型的隐藏状态为某个特定状态时，RNN会选择对应的专家来处理当前的输入。具体来说，它是用来控制当前时间步的输入数据应该由哪个RNN专家来处理，这样就能够实现对于不同数据区域的自适应分配，也就是对非平稳的适应。对不同区域的数据进行不同的处理，提高模型的灵活性和准确性。</p>
<p>在问题定义方面</p>
<p>介绍了一些字母的含义，描述研究问题，即输入是什么，输出是什么，最终得到一个什么样的模型，用到均方误差损失函数评估模型性能，作者也说明这个损失函数也可以换成MAE平均绝对误差。</p>
<p>由于这篇文章是基于RNN的一个模型，所以这里介绍了一下RNN用作时间序列预测的公式表示 $h_t=f_h(h_{t-1},x_t;\theta_h)=f_h(W_{hh}h_{t-1}+W_{xh}x_t)$</p>
<p><img src="/images/paperReading/image-20230416085527755.png" alt="image-20230416085527755" style="zoom:67%;" /></p>
<p>fh表示一个激活函数，一般是tanh函数，ht隐藏状态就是通过上一个隐藏状态ht-1和当前输入xt通过对应两个权重whh和wxh得到。然后，最后的预测结果yt即通过隐藏状态再通过一个权重why作用下，经过fy这个函数得到预测结果，一般来说这里的fy是softmax激活函数，但是在文章中写的是fy(x)=x这么一个一次函数。比较困惑，为什么这么设计。上面公式的权重表示为状态到状态之间转移的参数，下面公式的权重表示状态到观测值的一个映射关系所学习到的权重</p>
<p>在隐马尔可夫模型中，作者讲述到实用隐马尔可夫模型来模拟rnn的切换机制。这个hmm是一个统计模型。是一个有离散时间离散状态的携带者不可观测的隐藏状态kt的马尔科夫链。马尔科夫链表示隐藏状态在时间上的演变，它的联合概率分布公式如下</p>
<p><img src="/images/paperReading/image-20230416093009247.png" alt="image-20230416093009247"></p>
<p>其中，p(kt|kt-1;?)表示一个被转移矩阵定义的状态转移模型，表示上一个状态kt-1转移到当前状态kt的概率的动态演化过程。这个转移矩阵是一个k*k的矩阵，用来描述模型中不同时间点之间的转移的概率，里面每一个元素aij表示从状态i转移到状态j的概率。p(yt|kt;?)表示在kt状态下，观测值yt的概率。通常这里采用高斯分布来作为这个观测模型，因为它是一种常见的连续概率分布之一。</p>
<p>状态kt的后验概率p(kt|y1:T)称为滤波置信状态，是指在给定观测值y1:T下对状态kt的概率分布进行推断估计。这个可以通过前向算法来递归的估计，公式如下表示：</p>
<p><img src="/images/paperReading/image-20230416095519415.png" alt="image-20230416095519415"></p>
<p>最终，每一个时刻t的状态kt的后验概率都可以表示出来是通过前一时刻t-1的后验概率和当前时刻的观测值来进行递归的计算。p(yt|kt)是观测模型，p(kt|y1:t-1)是t-1时刻的过滤后验概率</p>
<p>用αt k ?p(kt = k| y1:T)表示第k个状态的置信值，也就是说在当前观测序列yt下，系统处于状态k的概率。然后定义at表示当前时刻t下，所有状态的后验概率信息，组成一个向量。φt 表示在某一个状态k下，观测值的概率，并把所有的这些概率组成的一个向量称为φt 似然向量。然后通过上面的前向算法递归的计算可以写成下面公式：</p>
<p><img src="/images/paperReading/image-20230416102446185.png" alt="image-20230416102446185"></p>
<p>上面的公式是针对某一个单一的状态进行的概率计算，而下面这个是对所有的状态概率的计算，？t表示描述状态与状态之间转移的概率的状态转移矩阵。通过这个公式就可以使用向量的形式方便计算这个p(kt|yt)了</p>
<p>方法</p>
<p>具有<font color='orange'>多个机制的内部修改网络</font>，<font color='orange'>基于hmm的切换机制</font>，框架的<font color='orange'>顺序学习算法</font></p>
<p>1】多个内部状态的马尔可夫rnn结构，每个状态独立控制隐藏状态转移，那既然每个状态都可以独立控制，就需要修改原来rnn预测的公式，之前rnn的预测公式的状态是整个序列对应的权重，而在这里权重需要和状态对应，即第k个状态对应第k个权重</p>
<p><img src="/images/paperReading/image-20230417080411632.png" alt="image-20230417080411632" style="zoom:67%;" /></p>
<p>在hmm中，每一个时间步的隐藏状态向量在不同的节点上进行传播，在传播时，它会受到这个θ(k)h的影响，因此，模型可以根据不同的状态，在不同的结点上独立地处理和传播隐藏状态向量，</p>
<p>状态k表示在当前时间步，模型系统处于第k个隐藏状态，把所有的这个k个状态赋予一定权重，得到t时刻的最终隐藏状态。这里要做区分的是，前面也有隐藏状态指的是在hmm当中，而后面的隐藏状态指的是rnn当中的，文章用regime来表示hmm中的隐藏状态进行区分，这里的k是一个超参数。下面公式的wtk是由<font color='orange'>切换机制</font>决定的</p>
<p><img src="/images/paperReading/image-20230417083851817.png" alt="image-20230417083851817"></p>
<p>这个模型可以拓展到不同的rnn结构中，如lstm和gru，以lstm为例，对每一个门控操作和单元状态更新可以为每个内部状态更新执行以下公式</p>
<p><img src="/images/paperReading/image-20230417085017924.png" alt="image-20230417085017924"></p>
<p><img src="/images/paperReading/image-20230417085055005.png" alt="image-20230417085055005"></p>
<p><img src="/images/paperReading/image-20230417085549635.png" alt="image-20230417085549635"></p>
<p>2】基于hmm的交换机制</p>
<p>在这个切换机制，可以用hmm的置信度来替换掉上面wtk权重。</p>
<p><img src="/images/paperReading/image-20230417091132317.png" alt="image-20230417091132317"></p>
<p>这里的at-1,k表示对于第k个隐藏状态的置信度。要计算at-1,k的话，按照公式6就需要先根据观察的yt计算第k时间步，φt的似然值</p>
<p>在损失函数MSE下，误差模型假设观测值yt可以表示为预测值ytk和误差etk之和，这个误差符合一个均值为零，方差为R的高斯分布，这个R表示第k个状态的误差协方差矩阵，它记录着状态到t-1时刻的所有误差。然后通过高斯分布的概率密度函数计算似然函数得到在状态为k下，得到观测值yt的概率取值</p>
<p><img src="/images/paperReading/image-20230417100505212.png" alt="image-20230417100505212"></p>
<p><img src="/images/paperReading/image-20230417100453557.png" alt="image-20230417100453557"></p>
<p>得到这个概率取值之后，就可以组成所有状态下1到K，K维似然向量φt，然后就可以更新隐藏状态置信向量at，知道at之后，就可以根据上面的公式计算ht了，最后计算出预测值yt</p>
<p><img src="/images/paperReading/image-20230417100754778.png" alt="image-20230417100754778"></p>
<p>还有一个地方，就是在高斯分布中和似然函数中的那个误差协方差矩阵，这里作者使用指数平滑的方法来更新这个误差协方差矩阵，利用β来控制平滑效果，使用交叉验证帮助确定最佳的β值。</p>
<p><img src="/images/paperReading/image-20230417101241713.png" alt="image-20230417101241713"></p>
<p>参数β可以理解为是在不同状态下误差容忍度的调节器，越大的β，这种切换的机制就会对误差越敏感，这样会导致状态的置信向量产生不稳定性和较高偏差。当它为0时，系统无法达到切换的能力。所以β的选择会直接影响模型</p>
<p>在给出的算法中，初始化模型权重为θ，隐藏状态为h1，置信向量α1</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Aiming</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Papers/"># Papers</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/03/29/SSM/spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/">spring事务控制</a>
            
            
            <a class="next" rel="next" href="/2023/03/28/SSM/spring-AOP/">AOP面向切面编程</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Aiming | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Aiming">





<title>java基础 | (●&#39;◡&#39;●)Iminslife</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/null"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Iminslife</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Iminslife</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">java基础</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Aiming</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 3, 2023&nbsp;&nbsp;10:01:10</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Offers/">Offers</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1、什么是面向对象"><a href="#1、什么是面向对象" class="headerlink" title="1、什么是面向对象"></a>1、什么是面向对象</h2><p>面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节。</p>
<p>面向过程更注重事情的每一步骤和顺序，而面向对象更注重事情有哪些参与者(对象)、以及各自需要做些什么。</p>
<p>面向过程会将任务拆解成一系列的步骤，而面向对象会将任务拆分为一个个对象，每个对象有什么方法。</p>
<p>面向过程比较直接高效，但是灵活性差，而面向对象虽然前期投入成本高，需要大量的分析，但是它更易于复用、扩展和维护。</p>
<p>面向对象有三个特性：封装、继承、多态</p>
<h2 id="2、说下面向对象三大特性"><a href="#2、说下面向对象三大特性" class="headerlink" title="2、说下面向对象三大特性"></a>2、<a target="_blank" rel="noopener" href="https://github.com/JavaInterviewHub/JavaInterview/blob/main/Java基础.md#1说下面向对象四大特性">说下面向对象三大特性</a></h2><ul>
<li><font color='orange'>封装</font>：封装的意义在于明确标识出允许外部使用的成员方法和数据。将类的某些信息隐藏在类的内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问</li>
<li><font color='orange'>继承</font>：理解为一个类从另一个类获取方法和属性的过程。如果B继承于A，那么B就拥有A的非私有方法和属性，可以直接使用。</li>
<li><font color='orange'>多态</font>：多态是在继承的基础上实现的。基于对象所属类的不同，外部对同一方法的调用，实际执行的逻辑不同。</li>
</ul>
<h2 id="3、访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#3、访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="3、访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>3、访问修饰符public,private,protected,以及不写（默认）时的区别？</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">当前类</th>
<th style="text-align:center">同 包</th>
<th style="text-align:center">子 类</th>
<th style="text-align:center">其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<p>private修饰的成员变量和函数只能在类本身和内部类中被访问。</p>
<p>protected 修饰的成员变量和函数能被类本身、子类及同一个包中的类访问。</p>
<p>默认情况（default）下，属于一种包访问，即能被类本身以及同一个包中的类访问。</p>
<p>public修饰的成员变量和函数可以被类、子类、同一个包中的类以及任意其他类访问。</p>
<h2 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f=3.4;是否正确？"></a>4、float f=3.4;是否正确？</h2><p>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<code>float f =(float)3.4</code>; 或者写成<code>float f =3.4F</code></p>
<h2 id="5、Java有哪些数据类型"><a href="#5、Java有哪些数据类型" class="headerlink" title="5、Java有哪些数据类型"></a>5、Java有哪些数据类型</h2><ul>
<li><font color='orange'>基本数据类型</font>：数值型、字符型char、布尔型Boolean。其中整数类型(byte,short,int,long)，浮点类型(float,double)</li>
<li><font color='orange'>引用数据类型</font>：类class、接口interface、数组</li>
</ul>
<h2 id="6、String-str-“i”-和String-str-new-String-“i”-一样吗？"><a href="#6、String-str-“i”-和String-str-new-String-“i”-一样吗？" class="headerlink" title="6、String str = “i” 和String str = new String(“i”)一样吗？"></a>6、String str = “i” 和String str = new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str = “i”的方式JVM会将其分配到<font color='orange'>常量池</font>中，而String str = new String(“i”)JVM会将其分配到<font color='orange'>堆内存</font>中。String是final修饰的，所以是将值放到了常量池中，而new String()是放到了堆内存中。</p>
<h2 id="7、Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7、Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7、Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7、Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><ul>
<li><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
</li>
<li><p>区别：</p>
<ul>
<li>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，再将指针指向新的 String 对象</li>
<li>而 StringBuffer 、 StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String</li>
<li>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的</li>
<li>但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer</li>
</ul>
</li>
<li><font color='yellow'>拓展</font>：<ul>
<li>StringBuffer 的所有公开方法都是 <font color='orange'>synchronized </font><font color='orange'>同步</font>修饰的，所以保证线程安全。而 StringBuilder 并没有 synchronized 修饰</li>
<li>StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串</li>
<li>StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串</li>
</ul>
</li>
</ul>
<h2 id="8、深克隆和浅克隆？"><a href="#8、深克隆和浅克隆？" class="headerlink" title="8、深克隆和浅克隆？"></a>8、深克隆和浅克隆？</h2><ul>
<li><font color='orange'>深克隆</font>：在深克隆中，无论源对象的成员变量是值类型还是引用类型，都将复制一份给目标对象，深克隆将源对象的所有引用对象也复制一份给目标对象。简言之，深克隆，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>
<li><font color='orange'>浅克隆</font>：在浅克隆中，如果源对象的成员变量是值类型，将复制一份给克隆对象；如果源对象的成员变量是引用类型，则将引用对象的地址复制一份给目标对象，也就是说源对象和目标对象的成员变量指向相同的内存地址。简言之，浅克隆，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li>
</ul>
<ul>
<li><font color='yellow'>拓展</font>：<strong>浅拷贝只会克隆基本数据属性，而不会克隆引用其他对象的属性，但String对象又不属于基本属性，这又是为什么呢？</strong><ul>
<li>String对象是不可修改的对象，每次修改其实都是新建一个新的对象，而不是在原有的对象上修改，所以当修改String属性时其实是新开辟一个空间存储String对象，并把引用指向该内存，而克隆出来的对象的String属性还是指向原有的内存地址，所以String对象在浅克隆中也表现得与基本属性一样。</li>
</ul>
</li>
</ul>
<h2 id="9、New一个对象的过程和clone一个对象的区别？"><a href="#9、New一个对象的过程和clone一个对象的区别？" class="headerlink" title="9、New一个对象的过程和clone一个对象的区别？"></a>9、New一个对象的过程和clone一个对象的区别？</h2><ul>
<li><font color='orange'>new </font>操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</li>
<li><font color='orange'>clone</font> 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象（即调用 clone 方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</li>
</ul>
<h2 id="10、什么是伪共享，如何解决？"><a href="#10、什么是伪共享，如何解决？" class="headerlink" title="10、什么是伪共享，如何解决？"></a>10、什么是伪共享，如何解决？</h2><p>如果此对象重写了equals方法，那么可能出现这两个对象的equals相同，而hashcode不同。因此可以说它是对的。 但是，如果此对象继承Object，没有重写equals方法，那么就使用Object的equals方法，Object对象的equals方法默认是用==实现的，那么如果equals相同，hashcode一定相同</p>
<h2 id="11、this关键字的用法"><a href="#11、this关键字的用法" class="headerlink" title="11、this关键字的用法"></a>11、this关键字的用法</h2><p>可以理解为：指向对象本身的一个指针。</p>
<p>用法一般分为三种：</p>
<ul>
<li>普通的直接引用，this相当于是指向当前对象本身</li>
<li>形参与成员名字重名，用this来区分</li>
<li>引用本类的构造函数</li>
</ul>
<h2 id="12、super关键字的用法"><a href="#12、super关键字的用法" class="headerlink" title="12、super关键字的用法"></a>12、super关键字的用法</h2><p>可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类</p>
<p>用法一般分为三种：</p>
<ul>
<li>指向当前对象的父类的引用</li>
<li>子类中的成员变量或方法与父类中的成员变量或方法同名时，可以通过 super 来调用父类里面的这个方法</li>
<li>可以在子类的构造方法中显式地调用父类的构造方法</li>
</ul>
<h2 id="13、static存在的主要意义"><a href="#13、static存在的主要意义" class="headerlink" title="13、static存在的主要意义"></a>13、static存在的主要意义</h2><p>static可以用来声明静态便变量和静态方法，可以被所有同一类的对象所共享，在类加载的时候会被初始化，且只被加载一次，所以当创建多个对象的时候，这些静态变量和静态方法也只有一个，被所有共享</p>
<p> 正由于它们是<code>共享</code>的，所以它们会存储在方法区当中，而不是在堆内存中，这样可以节省内存空间</p>
<p>但需要注意的是，非静态方法不能访问静态变量，静态方法不能访问非静态变量，总之就是，静态只能访问静态</p>
<h2 id="final关键字的用法"><a href="#final关键字的用法" class="headerlink" title="final关键字的用法"></a>final关键字的用法</h2><p>被final关键字修饰的变量、方法或者类，表示对象的一个最终形态，是不能够改变的，可以保证程序的<code>安全性</code>和<code>可靠性</code>，优化程序性能。</p>
<p>作用在变量前：表示这个变量是常量，一旦被初始化，其值就不能再被修改；</p>
<p>作用在方法前：表示这个方法不可以被重写，因为final修饰的方法已经是一个最终的实现</p>
<p>作用在类前：表示这个类不能有子类，也就是说这个类不可以被继承</p>
<h2 id="14、java中无参数构造方法有何作用？"><a href="#14、java中无参数构造方法有何作用？" class="headerlink" title="14、java中无参数构造方法有何作用？"></a>14、java中无参数构造方法有何作用？</h2><p>创建子类的对象实例的时候，必先调用父类的无参数的构造函数（默认构造函数），【创建子类，必先调用父类无参构造】</p>
<p>假如父类有带参数的构造函数，那么系统将不会给它创建无参数的构造函数，这时，子类在实例化的时候，因为找不到父类的默认构造函数，编译器将会报错，</p>
<p>但如果在子类的构造函数中指定用父类的带参数的构造函数的时候，或者在父类中加一个无参数的构造函数，就不会报错。</p>
<h2 id="15、静态变量和实例变量区别"><a href="#15、静态变量和实例变量区别" class="headerlink" title="15、静态变量和实例变量区别"></a>15、静态变量和实例变量区别</h2><ul>
<li><p><font color='orange'>静态变量</font>： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量<code>分配一次</code>内存空间。</p>
</li>
<li><p><font color='orange'>实例变量</font>： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，<code>创建几次对象，就有几份</code>成员变量。</p>
</li>
</ul>
<h2 id="16、静态方法和实例方法有何不同？"><a href="#16、静态方法和实例方法有何不同？" class="headerlink" title="16、静态方法和实例方法有何不同？"></a>16、静态方法和实例方法有何不同？</h2><ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ol>
<h2 id="17、内部类的分类有哪些"><a href="#17、内部类的分类有哪些" class="headerlink" title="17、内部类的分类有哪些"></a>17、内部类的分类有哪些</h2><p>内部类可以分为四种： 成员内部类、局部内部类、匿名内部类和静态内部类 。</p>
<ul>
<li><font color='yellow'>成员内部类</font>：定义在类内部，<font color='orange'>成员位置上的非静态类</font>，就是成员内部类。可以访问外部类<font color='orange'>所有</font>的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例</li>
<li><font color='yellow'>局部内部类</font>：定义在<font color='orange'>方法中的内部类</font>，就是局部内部类。可以访问外部类的所有变量和方法，定义在<font color='orange'>静态方法</font>中的局部类只能访问外部类的<font color='orange'>静态变量和方法</font>。</li>
<li><font color='yellow'>匿名内部类</font>：就是<font color='orange'>没有名字的内部类</font>。匿名内部类必须继承一个抽象类或者实现一个接口。匿名内部类的成员方法中可以访问其所在的外部类的成员变量（不论是否公有私有，不论是否静态非静态），变量相同时也是就近原则。匿名内部类不能定义任何静态成员和静态方法。当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li><font color='yellow'>静态内部类</font>：定义在<font color='orange'>类内部的静态类</font>。静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量。</li>
</ul>
<h2 id="18、Java中异常分为哪些种类？"><a href="#18、Java中异常分为哪些种类？" class="headerlink" title="18、Java中异常分为哪些种类？"></a>18、Java中异常分为哪些种类？</h2><ul>
<li><p>第一种：当前方法知道如何处理该异常，则用try…catch块来处理该异常。</p>
</li>
<li><p>第二种：当前方法不知道如何处理，则在定义该方法时声明抛出该异常。</p>
</li>
</ul>
<p><code>运行时异常</code>只有当代码在运行时才发现的异常，编译的时候不需要try…catch。Runtime如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>
<h2 id="受检查异常和非受检查异常的区别"><a href="#受检查异常和非受检查异常的区别" class="headerlink" title="受检查异常和非受检查异常的区别"></a>受检查异常和非受检查异常的区别</h2><p>受检异常是指必须要捕获的异常，否则无法通过编译。</p>
<p>非受检异常可以捕获也可以不捕获</p>
<h2 id="19、为什么重写equals时必须重写hashCode方法？"><a href="#19、为什么重写equals时必须重写hashCode方法？" class="headerlink" title="19、为什么重写equals时必须重写hashCode方法？"></a>19、为什么重写equals时必须重写hashCode方法？</h2><blockquote>
<p>总结：</p>
<ul>
<li>使用hashcode方法可以提前校验，减少equals方法调用，提高效率</li>
<li>如果重写了equals方法，可能存在squals相等，但是hashcode不等，所以为了避免这种情况，必须重写。</li>
</ul>
</blockquote>
<p>备注:为什么可以提高效率.</p>
<p>这是因为:在java中有一个set集合,是无序且元素唯一的. 如果每次添加元素都依靠equals判断,效率太慢,所以通过hash表,查看对应hashcode位置是否有值,这样效率就会更高.</p>
<p>如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的。</p>
<p>如果两个对象通过equals方法比较是不相等的，那么不要求它们的hashCode方法结果值是相等的。</p>
<p>当在一个应用程序执行过程中， 如果equals方法比较中没有修改任何信息，那么在同一个对象上重复调用hashCode方法时，它必须始终返回相同的值。但如果从一个应用程序到了另一个应用程序，两个应用程序汇中调用hashCode方法的返回值可以是不一致的。</p>
<p><strong>所以必须保证重写后的equals方法认定相同的两个对象拥有相同的哈希值</strong></p>
<h2 id="20、抽象类和接口（Java7）的区别"><a href="#20、抽象类和接口（Java7）的区别" class="headerlink" title="20、抽象类和接口（Java7）的区别"></a>20、抽象类和接口（Java7）的区别</h2><ul>
<li>抽象类：一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。对事物的整体进行抽象</li>
<li>接口：在JAVA编程语言中是一个抽象类型，是抽象方法的集合。对事物的局部行为进行抽象</li>
</ul>
<ol>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>
<li>抽象类可以有静态代码块和静态方法；而接口中不能含有静态代码块以及静态方法</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
<p>如果一个类中带有abstract的抽象方法，那么这个类就是一个抽象类，同时也必须在类前用abstract关键字修饰</p>
<p>如果一个非抽象类实现了某个接口，就必须实现该接口中的所有方法；如果实现了某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<h2 id="21、重写和重载的区别"><a href="#21、重写和重载的区别" class="headerlink" title="21、重写和重载的区别"></a>21、重写和重载的区别</h2><p><font color='yellow'>重写</font>：是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。重写的好处在于子类可以根据需要，定义特定于自己的行为。发生在子类和父类之间。[<font color='orange'>根据需要重新编写父类中的方法</font>]</p>
<p><font color='yellow'>重载</font>：发生在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。[<font color='orange'>方法名相同,但参数不同,返回值也可以不相同</font>]</p>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><p>两者都可以用作逻辑与的运算符，表示逻辑与and的意思，当两边的表达式结构都为true是，整个结果才为true，否则，只要有一个为false，结果为false</p>
<p>&amp;&amp;具有短路的功能，当第一个表达式为false时，不会计算第二个表达式</p>
<p>&amp;可以用作位运算符，当操作符两边的表达式不是boolean类型的时候，表示<code>按位与</code>操作</p>
<h2 id="switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h2><p>switch语句中表达式只能是一个整数表达式或者枚举常量。一些byte，short，char类型可以隐含转为int类型，是可以支持的。</p>
<p>switch不支持long类型</p>
<p>在java1.7之后开始支持string</p>
<h2 id="“-”和equals方法究竟有什么区别"><a href="#“-”和equals方法究竟有什么区别" class="headerlink" title="“==”和equals方法究竟有什么区别"></a>“==”和equals方法究竟有什么区别</h2><p><code>==</code>用于比较两个对象的内存地址是否相同。如果两个对象的<font color='orange'>内存地址</font>相同，则它们是同一个对象</p>
<p>而<code>equals</code>方法是Object类中定义的方法，用于比较两个对象的<font color='orange'>内容</font>是否相等。</p>
<ul>
<li>默认情况下，equals方法比较的是两个对象的内存地址是否相同，即与”==”作用相同。</li>
<li>但是，我们可以通过在类中重写equals方法来改变它的比较方式，使其比较对象的内容是否相等。</li>
</ul>
<blockquote>
<p>“==”用于比较两个对象的内存地址是否相同，而equals方法用于比较两个对象的内容是否相同。</p>
</blockquote>
<h2 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h2><ul>
<li>作为成员变量：integer的初始值是null，int的初始值是0</li>
<li>存储方式：integer实际存储的是对象的引用，存储在堆内存的；int类型存储的是数据值，存储在栈空间</li>
<li>integer是对象类型，封装很多方法和属性，使用更加灵活。</li>
<li>比较方式不一样：int使用==比较，integer使用equals方法比较</li>
</ul>
<p>java是面向对象的语言，一切操作都是以对象作为基础，包装类的存在解决了基本数据类型无法做到的事情</p>
<h2 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h2><p>可变性：string内部的value值是final修饰的，是不可变类，每次修改值时，都会产生一个新的对象。StringBuffer和StringBuilder是一个可变类，字符串的变更不会产生一个新的对象</p>
<p>线程安全性：string是不可变类，所以线程安全；StringBuffer也是线程安全的，因为操作方法里面有synchronized关键字修饰；而StringBuilder线程不安全的</p>
<p>性能上：string性能最低，因为每次操作都会产生一个新的对象，要分配心得内存空间；StringBuffer性能高于string，多次修改字符串不会产生新的对象，但是由于它加了同步锁保证线程安全，所以性能要低于StringBuilder</p>
<p>存储方面：<code>string</code>存储在<font color='orange'>字符串常量池</font>中，<code>StringBuffer</code>和<code>StringBuilder</code>存储在<font color='orange'>堆内存</font>中</p>
<h2 id="Java中的异常处理机制的简单原理和应用"><a href="#Java中的异常处理机制的简单原理和应用" class="headerlink" title="Java中的异常处理机制的简单原理和应用"></a>Java中的异常处理机制的简单原理和应用</h2><p>当程序发生异常时，可以通过异常处理机制来保证程序的健壮和稳定，有两个子类实现：error和exception，error是指程序无法处理的错误，exception指的是程序在运行时需要处理的异常。受检异常和非受检异常都是派生自exception这个类</p>
<ul>
<li>受检异常：是指程序在编译阶段必须要主动捕获的异常，处理方式有try…catch捕获或者throw抛出去</li>
<li>非受检异常：不需要进行捕获， 一般发生在程序运行期间</li>
</ul>
<h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>相同点：都可以完成对数据的<font color='orange'>读取</font>和<font color='orange'>写入</font>操作，本质上都是以<code>字节</code>为单位的读取</p>
<p>不同点：</p>
<ul>
<li><p>组成不同：字节流是由字节组成；字符流是由字符组成的</p>
</li>
<li><p>缓冲区不同：字节流是字节在文件上进行操作，没有用到缓冲区；字符流会用到缓冲区，通过缓冲区操作文件</p>
</li>
<li><p>操作对象不同：字节流可以操作所有类型的文件，可以拷贝任意类型文件；字符流适合处理文本文件，读取纯文本文件数据，写入数据</p>
</li>
<li><p>处理方式不同：字节流采用ASCII编码，处理二进制数据；字符流采用Unicode编码，进行字符集转化</p>
</li>
</ul>
<h2 id="什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"><a href="#什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用" class="headerlink" title="什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"></a>什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用</h2><p>java序列化时至java对象转化为字节序列的过程。要实现java序列化使用java提供的<code>serializable</code>接口，表示这个java类是可以被序列化的，并且传输到其他地方。实现的步骤如下：</p>
<ul>
<li>实现serializable接口</li>
<li>创建一个ObjectOutputStream对象，通过它将Java对象转换为字节流。</li>
<li>创建一个ObjectInputStream对象，通过它将字节流转换为Java对象。</li>
</ul>
<h2 id="GC是什么，垃圾回收的优点和原理"><a href="#GC是什么，垃圾回收的优点和原理" class="headerlink" title="GC是什么，垃圾回收的优点和原理"></a>GC是什么，垃圾回收的优点和原理</h2><p>GC：gc是<font color='orange'>自动回收内存</font>的机制，可以自动检测对象是否不再被程序所使用，从而达到自动回收内存的目的</p>
<p>优点：垃圾回收可以有效防止内存泄漏，有效地使用那些可以使用的内存</p>
<p>原理：垃圾回收器有一个低级别的线程处理，对<font color='orange'>堆内存</font>中已经死亡的或者长时间没有使用的对象进行清理和回收</p>
<p>如果一个对象长时间没有使用，但是这个对象被其他对象所引用，那么无法被垃圾回收器回收，可能会出现内存泄漏的情况</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Aiming</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Offers/"># Offers</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/05/03/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9B%86%E5%90%88/">java集合</a>
            
            
            <a class="next" rel="next" href="/2023/04/25/DataBase/mysql%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7/">mysql基础高级</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Aiming | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Aiming">





<title>java集合 | (●&#39;◡&#39;●)Iminslife</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/null"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Iminslife</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Iminslife</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">java集合</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Aiming</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 3, 2023&nbsp;&nbsp;15:02:43</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Offers/">Offers</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1、Java集合体系框架图"><a href="#1、Java集合体系框架图" class="headerlink" title="1、Java集合体系框架图"></a>1、Java集合体系框架图</h2><p><img src="/images/java%E9%9B%86%E5%90%88/640.webp" alt="img" style="zoom: 67%;" /></p>
<h2 id="2、常见的集合有哪些？"><a href="#2、常见的集合有哪些？" class="headerlink" title="2、常见的集合有哪些？"></a>2、常见的集合有哪些？</h2><ul>
<li><p><code>Collection</code>接口的子接口包括：Set接口和List接口。</p>
<ul>
<li><code>Set</code>接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 </li>
<li><code>List</code>接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
</li>
<li><p><code>Map</code>接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 </p>
</li>
</ul>
<h2 id="3、常见的集合底层实现"><a href="#3、常见的集合底层实现" class="headerlink" title="3、常见的集合底层实现"></a>3、常见的集合底层实现</h2><p>ArrayList底层是数组。 LinkedList底层是双向链表。 HashMap底层与HashTable原理相同，Java 8版本以后如果同一位置哈希冲突大于8则链表变成红黑树。 HashTable底层是链地址法组成的哈希表（即数组+单项链表组成）。 HashSet底层是HashMap。 LinkedHashMap底层修改自HashMap，包含一个维护插入顺序的双向链表。 TreeMap底层是红黑树。 LinkedHashSet底层是LinkedHashMap。 TreeSet底层是TreeMap。</p>
<h2 id="4、HashMap与HashTable的区别？"><a href="#4、HashMap与HashTable的区别？" class="headerlink" title="4、HashMap与HashTable的区别？"></a>4、HashMap与HashTable的区别？</h2><p>hashmap和hashtable都是一个基于hash表实现的k-v结构的集合。</p>
<ul>
<li><p><code>hashtable</code>是<font color='orange'>线程安全</font>的集合类，因为所有数据访问的方法都加了一个<font color='orange'>synchronized同步锁</font>。这对于<font color='orange'>性能影响比较大</font>。其内部采用了<font color='orange'>数组加链表</font>来实现。链表主要是为了解决hash表的一个hash冲突的问题。<font color='orange'>初始容量是11</font>，<font color='orange'>不允许使用null作为key</font></p>
</li>
<li><p><code>hashmap</code>是一个<font color='orange'>线程不安全</font>的集合类，<font color='orange'>性能优</font>于hashtable其内部也采用了<font color='orange'>数组和链表</font>来实现。在jdk1.8之后引入了红黑树，当<font color='orange'>链表</font>长度大于等于<font color='orange'>8</font>，并且<font color='orange'>数组</font>长度大于<font color='orange'>64</font>的时候，就会把链表转换为<font color='orange'>红黑树</font>，以此提升数据查找的一个性能。<font color='orange'>初始容量是16</font>，<font color='orange'>允许k和v都为null</font></p>
</li>
</ul>
<h2 id="5、HashMap是如何解决hash冲突的？"><a href="#5、HashMap是如何解决hash冲突的？" class="headerlink" title="5、HashMap是如何解决hash冲突的？"></a>5、HashMap是如何解决hash冲突的？</h2><ul>
<li>hashmap底层是通过数组来存储元素的，数组的默认长度是16，当通过put方法添加数据的时候，hashmap会根据key的哈希值进行取模运算，最终把值保存到数组的指定位置。</li>
<li>为了避免两个不同hash值的key落到一个同一个数组的下标，所以引入了一个链式寻址法来解决。</li>
<li>在后面加上一个单向链表，采用尾插法把key保存到链表的尾部。为了避免链表过长，在jdk1.8之后，引入了红黑树，当<font color='orange'>链表</font>长度大于等于<font color='orange'>8</font>，并且<font color='orange'>数组</font>长度大于<font color='orange'>64</font>的时候，就会把链表转换为<font color='orange'>红黑树</font>，减少查询复杂度</li>
<li>拓展：<ul>
<li>再哈希法：在用一个哈希函数处理冲突的key</li>
<li>开放寻址法：直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储</li>
<li>建立公共溢出区： 把存在冲突的key统一放在一个公共溢出区里面进行存储</li>
</ul>
</li>
</ul>
<h2 id="6、ArrayList和LinkedList的区别？"><a href="#6、ArrayList和LinkedList的区别？" class="headerlink" title="6、ArrayList和LinkedList的区别？"></a>6、ArrayList和LinkedList的区别？</h2><ul>
<li>两者之间的数据结构不同：对于ArrayList来说它底层是数组结构，对于LinkedList来说底层是链表结构。</li>
<li>由于arraylist底层是数组结构，所以在内存是一块连续的区域，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素；</li>
<li>linkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)</li>
<li>自由性不同，在创建arraylist时需要指定数组的长度，而创建linkedlist只需要关系指针和每个元素</li>
</ul>
<h2 id="7、集合中的泛型如何保证安全性"><a href="#7、集合中的泛型如何保证安全性" class="headerlink" title="7、集合中的泛型如何保证安全性"></a>7、集合中的泛型如何保证安全性</h2><ul>
<li>是一种强制集合存储类型。确保我们定义的类型是安全的，不会出现转换出错问题。避免类型的转换</li>
<li>安全问题由运行时期提前到了编译时期。也就是说，在类定义处声明的泛型，则用来指定这个类用来处理的对象类型，这个类中定义的所有方法，只要使用了类定义处声明的泛型参数，则都必须使用同一个对象，否则，编译就会出现错误</li>
</ul>
<h2 id="8、Comparable和Comparator接口有何区别？"><a href="#8、Comparable和Comparator接口有何区别？" class="headerlink" title="8、Comparable和Comparator接口有何区别？"></a>8、Comparable和Comparator接口有何区别？</h2><ul>
<li>Comparable和Comparator接口，都可以用来实现集合中元素的比较、排序</li>
<li>Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。</li>
<li>Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。</li>
</ul>
<ul>
<li>Comparable接口位于Java.lang包下；而Comparator接口位于java.util包下。</li>
<li>如果一个类中要实现Comparable接口进行排序，就必须在类中重写compareTo()方法，入侵式排序；如果利用实现Comparator接口进行排序，则可以自定义一个类来实现Comparator接口，并重写compare()方法。然后再需要比较的类中创建自定义类的对象进行比较。非入侵式排序</li>
</ul>
<h2 id="9、hashmap中的hash方法为什么要右移16为异或运算"><a href="#9、hashmap中的hash方法为什么要右移16为异或运算" class="headerlink" title="9、hashmap中的hash方法为什么要右移16为异或运算"></a>9、hashmap中的hash方法为什么要右移16为异或运算</h2><ul>
<li>核心目的是为了让hash值的散列度更高，尽可能的减少hash表的hash冲突，从而提升数据的查找性能</li>
<li>在hashmap的put方法里，是通过key的hash值与数组的长度取模计算得到数组位置，在绝大部分情况下，put方法里的n值一般是小于$2^{16}$，所以计算出来的值是使用hash值的低16位与n-1进行取模计算，造成了key的散列度不高，导致大量的key集中存储在一个固定的几个数组位置上。</li>
</ul>
<h2 id="10、hashmap扩容原理"><a href="#10、hashmap扩容原理" class="headerlink" title="10、hashmap扩容原理"></a>10、hashmap扩容原理</h2><p>当hashmap中的元素个数超过临界值的时候，会自动触发扩容机制。临界值=负载因子×容量大小  负载因子等于0.75，容量大小为16，也就是说，当元素个数达到12个会触发扩容，扩容之后的大小是原来的两倍。</p>
<p>集合初始化时明确集合大小，避免频繁扩容带来的性能下降</p>
<p>扩容因子0.75表示hash表中元素填充的程度。值越大，触发扩容的元素个数会更多，空间利用率增加，同时哈希冲突的概率也会增加。值越小，触发扩容的元素个数会更少，浪费了空间，哈希碰撞的概率会减小，所以这个值是平衡空间成本和时间成本。 </p>
<h2 id="11、arraylist扩容原理"><a href="#11、arraylist扩容原理" class="headerlink" title="11、arraylist扩容原理"></a>11、arraylist扩容原理</h2><p>arraylist是一个数组结构的存储容器，默认情况下数组的长度是10，也可以在创建对象的时候指定初始长度。 当添加数据达到这个数组的长度时，arraylist会触发自动扩容机制。</p>
<ul>
<li>创建一个新的数组，这个数组的长度时原来数组长度的1.5倍 </li>
<li>然后利用Arrays.copyOf方法把老数组里面的元素复制到新数组中去</li>
<li>复制完之后，再把新要添加的元素，插入到新数组中去</li>
</ul>
<h2 id="12、Collections-sort和Arrays-sort的实现原理"><a href="#12、Collections-sort和Arrays-sort的实现原理" class="headerlink" title="12、Collections.sort和Arrays.sort的实现原理"></a>12、Collections.sort和Arrays.sort的实现原理</h2><p>Collections.sort方法调用了list.sort方法，而list.sort方法又调用了Arrays.sort的方法。所以，Collections.sort方法底层就是调用的Array.sort方法</p>
<p>在arrays.sort()会根据不同的情况使用不同的排序算法。</p>
<ul>
<li>基本数据类型下：分为元素个数不同分为三种情况<ul>
<li>元素个数len&lt;47时，使用插入排序</li>
<li>当47&lt;=元素个数len&lt;286时，使用双轴快速排序</li>
<li>当元素个数＞286时，使用归并排序 </li>
</ul>
</li>
<li>泛型类型下：Collections.sort方法最终调用针对泛型的Array.sort方法，根据有无比较器会分别调用TimSort或者ComparableTimSort算法，这都是基于归并排序的一种优化算法，在归并排序的基础上加上了插入排序。</li>
</ul>
<h2 id="13、List-和-Set，Map-的区别"><a href="#13、List-和-Set，Map-的区别" class="headerlink" title="13、List 和 Set，Map 的区别"></a>13、List 和 Set，Map 的区别</h2><ul>
<li>List 以索引来存取元素，有序的，元素是允许重复的，可以插入多个null。</li>
<li>Set 不能存放重复元素，无序的，只允许一个null</li>
<li>Map 保存键值对映射，映射关系可以一对一、多对一</li>
<li>List 有基于数组、链表实现两种方式</li>
<li>Set、Map 容器有基于哈希存储和红黑树两种方式实现</li>
<li>Set 基于 Map 实现，Set 里的元素值就是 Map的键值</li>
</ul>
<h2 id="14、TreeMap底层？"><a href="#14、TreeMap底层？" class="headerlink" title="14、TreeMap底层？"></a>14、TreeMap底层？</h2><ul>
<li>TreeMap底层数据结构是一个红黑树，每个key-value都作为一个红黑树的节点。</li>
<li>如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。</li>
<li>每次新增或删除结点，都可能导致红黑树的重排，这样的效率比不上hashmap，如果不是需要对数据有序的情况下，可以考虑hashmap</li>
</ul>
<h2 id="15、HashSet是如何保证不重复的"><a href="#15、HashSet是如何保证不重复的" class="headerlink" title="15、HashSet是如何保证不重复的"></a>15、HashSet是如何保证不重复的</h2><p>当我们在往hashset集合里面添加元素的时候，会通过add()方法，这个方法返回的是map.put()方法，而map中的key是不允许重复的，这保证了hashset里面的元素是不重复的。</p>
<p>具体来说：其本质上就是map保证元素不重复。当要插入的元素通过hash计算该元素的位置，如果该位置没有元素就插入，返回null；如果有元素，就会通过equals进行判断，是不是重复元素，如果是重复元素，那么最后返回这个重复元素。</p>
<h2 id="16、迭代器-Iterator-是什么？怎么用，有什么特点？"><a href="#16、迭代器-Iterator-是什么？怎么用，有什么特点？" class="headerlink" title="16、迭代器 Iterator 是什么？怎么用，有什么特点？"></a>16、迭代器 Iterator 是什么？怎么用，有什么特点？</h2><ul>
<li><p>Iterator 是一个对象，可以用来遍历并选择序列中的对象。</p>
</li>
<li><p>使用</p>
<ul>
<li>要使用iterator方法需要容器先返回一个Iterator。（前提）第一次调用next()方法，他返回序列的第一个元素；</li>
<li>在使用next()方法获取序列的下一个元素；</li>
<li>使用hasnext()方法检查序列中是否还有元素；</li>
<li>使用remove()方法删除迭代器返回的新元素。</li>
</ul>
</li>
<li>特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</li>
</ul>
<h2 id="17、有没有有顺序的Map实现类，如果有，他们是怎么保证有序的"><a href="#17、有没有有顺序的Map实现类，如果有，他们是怎么保证有序的" class="headerlink" title="17、有没有有顺序的Map实现类，如果有，他们是怎么保证有序的"></a>17、有没有有顺序的Map实现类，如果有，他们是怎么保证有序的</h2><p>hashmap和hashtable是无序的；</p>
<p>treemap和linkedhashmap是有序的，treemap默认是key升序，linkedhashmap默认是数据插入顺序</p>
<p>​    treemap是基于比较器comparator来实现有序的</p>
<p>​    linkedhashmap是基于链表来实现数据插入有序的</p>
<h2 id="18、HashSet和TreeSet有什么区别？"><a href="#18、HashSet和TreeSet有什么区别？" class="headerlink" title="18、HashSet和TreeSet有什么区别？"></a>18、HashSet和TreeSet有什么区别？</h2><ul>
<li>hashset的底层是由哈希表实现的，而treeset的底层是由红黑树实现的</li>
<li>hashset中的元素是无序的，而treeset中的元素是有序的，它通过实现comparable接口</li>
<li>hashset的add(),remove(),contains()方法的时间复杂度为O(1)；treeset中，add(),remove(),contains()方法的时间复杂度为O(logn)</li>
</ul>
<h2 id="java中fail-fast和fail-safe的区别"><a href="#java中fail-fast和fail-safe的区别" class="headerlink" title="java中fail-fast和fail-safe的区别"></a>java中fail-fast和fail-safe的区别</h2><p>两种机制适用于多线程环境下的迭代器iterator的行为控制机制。</p>
<p>fail-fast指在遍历集合时，如果集合的结构发生变化，就会抛出当前修改异常，而fail-safe不会抛出异常，它通过复制一份集合副本实现遍历，所以即使原始集合发生变化，也不会影响副本的遍历。</p>
<p>正是由于对副本的拷贝，所以空间开销比较大。fail-fast时效性强，能够快速发现程序错误</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Aiming</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Offers/"># Offers</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/05/03/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">java多线程</a>
            
            
            <a class="next" rel="next" href="/2023/05/03/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E5%9F%BA%E7%A1%80/">java基础</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Aiming | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>